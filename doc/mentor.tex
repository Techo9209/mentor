\documentclass[a4paper,11pt]{article}
\newcommand{\probe}{\emph{\sc{probe{}}}}
\newcommand{\bs}{$\backslash$}
\usepackage{graphicx}

\begin{document}

% {{{1 Introduction

\section{Title}
% how to get a nice title

MENTOR
flash-card system for improving learning\\
Author: Adam Folmert <afolmert@gmail.com>\\

\section{Table of contents}
1. Introduction\\
2. Installation\\
3. Basic usage\\
4. Managing flashcards\\
5. Repetitions\\
6. Importing and exporting\\
7. Extracting from articles\\

Appendix\\

8. Probe tool\\
8a. Introduction\\
8b. Usage\\
8c. Markup language\\
8d. Extending\\


\section{Introduction}

\section{Installation}

\section{Basic usage}


\section{Managing flashcards}


\section{Repetitions}

\section{Importing and exporting}

\section{Extracting from articles}


\section{Appendix}
\section{Introduction}

\probe\ is a tool for extracting and rearranging knowledge from documents in
a way which makes it more suitable for understanding and learning. It uses a
special markup language to mark the interesting parts of a document
and then extracts those parts and presents them in way that can be exported
to flash-card programs like SuperMemo, Mnemosyne or Mentor.

For example, let's assume here is a text you want to get some info from:
\textit{Christoph Columbus was a great adventurer. America was discovered by
Columbus in 1492.}

If you want to learn the extractant facts from given text, you modify it
slightly by adding extract markup:
\begin{verbatim}
\begin{cloze}
Christoph Columbus was a \?{great adventurer}. America was discovered by
\?{Christoph Columbus} in \?{1492}.
\end{cloze}
\end{verbatim}

Running extract over thusly modified text, will result in the following:
\begin{verbatim}
q: Christoph Columbus was a ....
a: great adventurer

q: America was discovered by ... in 1492
a: Christoph Columbus

q: America was discovered by Christoph Columbus in ...
a: 1492
\end{verbatim}

The resulting items may now be exported to a flashcard program for memorizing.

extract can be also used to quickly prepare knowledge cloze tests over a wide
range of different texts, like: programming code, articles etc.



-- sense of flashcard programs ---

If you never met a flashcard program before : it is a tool presenting knowledge
in a form of cards. On each card there is stored one item which is repeatedly
presented to you, until all knowledge is remembered.

The most known example of such program is SuperMemo designed by Piotr Wozniak.


SuperMemo is a program for improving the learning process by keeping track of
your repetition schedule. It's mainly used in foreign language study, although
it can be applied to any kind of knowledge.

It is a great way of learning but it presents a special problem: how to
construct the knowledge ...?

TODO here add some more

The idea of the program is to split the knowledge into distinct items with a
question and answer e.g. \emph{Q: mother A: die Mutti} for german vocabulary
item or \emph{Q: when did II World War begin A: 1939} for historical item.  The
user has to review the items regularly by looking at the questions and trying
to come up with the answer in his head. Then the program displays the answer
and user has to assign himself a score basing on the quality of his answer.
Then the item is scheduled to be reviewed in some future time and user selects
another item and so on.

The great part about SuperMemo is the scheduling algorithm which tries to
optimize the time break needed for next review, basing on user-assigned score,
item difficulty, general user profile and database difficulty. The optimal
schedule time is just before the item is about to be forgotten so that the
review provides most benefits to user memory and items are not stacked up too
quickly.  It is not uncommon for SuperMemo users to have tens of thousands of
items in their databases and yet not spending more than a couple of minutes
each day to have the scheduled items reviewed.




%====================
\subsubsection{\probe\ goal}

The purpose quickly generating lots of items for supermemo  and i'm testing
this great purpose editor and i'm not sure how it works



Generally I should be able to just paste cheatsheet then apply some little/mall
markup rules to better transform learning process There should be as little
changes to the original texts as possible - the XML markups just go out of
question

I will create cheatsheets and out of this cheatsheets -> just a little command
to generate supermemo items as well

The stynax colors should make the additional words not really visible just like
ocmments The idea The syntax is generally based on TEX/LATEX markups


The most time-consuming part of SuperMemo usage is the creation of those item
databases. There already exist plenty of ready-made database for most foreign
languages (on different difficulty levels) and for common knowledge areas like
geography, literature etc. but it is often useful or required to create
custom-made databases. This is especially true for non-language databases, e.g.
when one wants to learn facts from some articles or tutorials. Manual input of
data to SuperMemo is quite cumbersome and impractical if one wants to learn
lots of knowledge.

This is the gap that this \probe\ program is trying to fill.

The aim of this tool is to automatically extract valuable knowledge from texts
and presents them in format which can be readily extracted to SuperMemo. The
extraction process can be fully customized by using a simple markup language
which you may put in the text to annotate which fragments must be exported and
in what way should they be presented in SuperMemo.


the aim of this tool is to generally tweak all the way it's used gr

%====================
\subsubsection{\probe\ name}

Most specifically, \probe\ is a tool to automate creation of SuperMemo items.
The name is abbreviation for \emph{SuperMemo EXport}.

This should really go in the reference below: for one extract is an acronym for
SuperMemo ITEms which is a common-sense name for SuperMemo add-on tool.  The
second meaning might be in \emph{smiting dark evil} which is a metaphore for
bringing light to dark minds and trying to lighten the path of no-knowledge.
And the last which comes to my mind is , obviously, the required recursive
acronym name which may be \emph{extract is the elite} or \emph{extract might
include teaching erudite}.  This is just a crude comment, please don't take it
too seriously.. .




% 1}}} Introduction
% {{{1 Usage
\section{Usage}

\probe\ is a command-line utility and it's basic usage involves just running the
script from the shell with a parameter of text file you want to export:
\begin{verbatim}
extract article.txt
\end{verbatim}

This will print the items for the file to the screen. If you want to save those
items in a kind of file, you could run:
\begin{verbatim}
extract article.txt > article.out
\end{verbatim}
and then the file article.out will be generated.
It can be extracted to SuperMemo by selecting from menu:
File->Tools->extract->Q\&A text
The items will then appear in a new SuperMemo branch.


In it's default configuration, \probe\ will export all paragraphs from the
file, creating one item for each word in paragraph, resulting in cloze
items:
e.g. from paragraph:
\begin{verbatim}
The World War II broke in 1939 year.
\end{verbatim}
the following items will be created:

\begin{verbatim}
Q: The ... II broke in 1939.
A: World War

Q: The World War ... broke in 1939.
A: II

Q: The World War II broke in ....
A: 1939
\end{verbatim}

The common words like \textit{the}, \textit{broke} and \textit{in} are ignored
from the cloze to avoid creation of too many unecessary items.

In order to customize what should be exported from the file and how the
items should be created you can use a special markup language to annotate the
file.  The markup language gives hints to \probe\ how it should export the
text.
In it's default state, \probe\ will try deduce the format of the given file
and export items in most useful state. If you want to control what items are
exported you have to modify the file contents, using special extract markup
language (called extract as well).


extract default behaviour may be often inappropriate and you may want to
customize it. extract command-line interface provides numerous options and switches

\subsubsection{Options and switches}
There are a set of command-line options which may be used to control extract
behaviour:

Here are the most common configuration options:

--quick -q tries to parse text intelligently without any markup

--debug -d writes debug output

--verbose -v writes verbose information

--swap=off/on should generate swapped items as well?

--class = tries to use given class when parsing the file

The currently supported classes are: tabular, cloze, sentences, paragraphs,
code and graphical.

The switches and options provided by extract command-line interface may be often
now enough. In some cases a more fine-grained control may be needed.
In order to have full control over extract export, you will have to modify the
document, using simple extract markup language.

% 1}}} Usage
% {{{1 probe markup language
\section{\probe\ markup language}
%{{{2 Introduction
\subsection{Introduction}
It may happen that the defaults used by \probe\ are not sufficient to extract
to knowledge or you may want to tweak the questions and answers generated by
\probe\ so that you can memorize them more easily.

To achive this you may want to use the extract markup language.

% write about what are markup languages like SGML, HTML and LaTeX family extract
% tries to be as minimal and unobtrusive as possible and yet poweful to be able
% to tweak the way in which items are extracted.


The basic design goal of the extract language was to make it as unobtrusive as
possible - so that I could use the files as a real cheatsheet - yet make it
quite powerful and expressive so that I could specify exactly what I want to
learn from given piece of text.


The basic requirement I have for \probe\ is to be as efficient as possible
when extracting the information from text.

The requirement means that it should be as minimalistic as possible, so that I
can e.g. take an existing cheatsheet, add some annotations and it will be
exported correctly. I don't want to spend day by tweaking the document to have
a desired result.

In no mood to reinvent the wheel I modelled the language mainly after LaTeX as
it's quite lightweight. Of course it is not a proper LaTeX syntax and cannot be
processed by latex tools - it only has some superficial similarities which make
easier for people familiar with LaTeX to start using it right away.  I also
added some special tweaks and shortcuts after currently popular light-html
markups like markdown and textile to make the language even more lightweight.

- requirements for language: minimalistic - extracting information in a subtle
way

extract markup language is a special language for marking text in a way that can
be understood by extract. It is superficially smiliar to such languages like TeX,
HTML or currently popular languages like Markdown etc.

It is quite a forgiving language - it uses the same idea as the web
browsers - it tries to parse what it can parse, and in case of errors it tries
to deduce the best meaning. It has also the strict option which makes it
possible to detect the errors quickly.

The Smex language is not one language - it is specifically a collection of
different languages - each one being a specific class.

They are called classes and determine how the text should be processed. The
classes share some similarities (e.g. option settings) but generally each class
tries to blend with the type of text it tries markup.

It is superficially similar to LaTeX.

\subsubsection{General ideas}
General idea is that the source text should be as intact as possible - that
means that everything that is not inside markup should be treated as a comment.

TODO see the info about the comment!!

I just should take the text , apply some markup here and there, without
modifying the original, and have it output text exactly how I need it.

TODO rethink this example:

\begin{verbatim}
Example
\begin???
 FIXmarkup A group is an enclosure for a collection of text FIXendmarkup and commands which encloses
 the formatting context and constrains the scope of any changes to that context
 made by commands within the group. FIXmarkup Groups can be nested hierarchically. The
 formatting context includes the font and the definition of additional macros
 (or overrides of macros defined in outer groups). FIXendmarkup Syntactically, groups are
 enclosed in braces:
\end???

\end{verbatim}


% 2}}}
% {{{2 General constructs
\subsection{General constructs}
These are general constructs which constitute the extract markup language. They
may be used anywhere in the file.
Class specific constructs are given in the next section.

BTW, what's the difference between general constructs and options? see later??


% {{{3 FIXbegin
\subsubsection{FIXbegin and FIXend options}
The most general construct is FIXbegin and FIXend. They mark the beginning of
special class which is used to parse the text contained in it.

It determines what class should be chosen for parsing the file.

The class may be one of the following:
\emph{tabular}, \emph{sentence}, \emph{code} and \emph{qa} and others which
will be described later.

This construct may contain option settings in [ ]:
the possible options are \emph{swap} , \emph{prefix}, \emph{mainprefix} and
others.


The construct of chosing class is similar to what we call environment in LaTeX
(again similarly to LaTeX):

TODO must select different font for these to work !!!!

1. \char92 items construct This is the basic construct which marks the text to
be processed by \probe\. By default \probe\ processes the whole file unless it
encounters this construct - then only the text between those tags is processed
and the text outside this construct is ignored.

\char92 items{class}[options]
\char92 enditems{class}

The {class} determines the type of export \probe\ should use. Currently
there are several types of export and each one treats the

A class determines how the text should be treated. It determines the rules ,
class and algorithm that is selected to process given text chunk.  It is
possible to extend \probe\ with custom classes whenever you feel there are
some texts you would like to learn in a special way or modify existing classes
by deriving from them and creating new classes.

% 3}}} FIXbegin

% {{{3 FIXprefix
\subsubsection{FIXprefix}
This option is used to prefix the question with some text. It may be useful
when we have many different types of questions in a database and to distinguish
between them, we use a prefix.

Prefix can have many levels and different delimiters. It is all controlled by
options.

Example:
\begin{verbatim}
\prefix{ala,ma,kota}[delim=:]
\end{verbatim}

What about nested prefixes??
I want to specify prefix at the beginning and then in subchapter

Maybe use something more similar to LaTeX section and subsections??
plus option of using it as a prefix
Example:
\begin{verbatim}
\title{Vim editing}[prefix=vim]
OR
\title{Vim editing}[vim]
\option[prefix=yes;prefix-delim=:]
\section{Pattern search}[pattern-search]
[...]
\subsection{Regexp search}[regexp]
[...]
\end{verbatim}

this will result in the following prefixes:
\begin{verbatim}
vim: pattern-search: regexp

\end{verbatim}

% 3}}} FIXprefix

% {{{3 FIXinclude
\subsubsection{FIXinclude option}
This option is used to include another file in the current in current file.

It is similar to C/C++ preprocessor directive which includes the content of
another file in given file.
This may be useful when you want to have your articles nicely splitted among
different files but want to have only one file to process.

Example usage:
\begin{verbatim}
\begin{set}
\include{sample.txt}
[...]
\end{verbatim}

This will include sample.txt file to the currently processed file.
Note that the processing will be done according to currently active options. In
this case, the file will be processed as \textit{set mode}.

The file must be present in current path or in PATH variable.
% 3}}}
% {{{3 FIXcommon
\subsubsection{FIXcommon option}
This construct includes common words in current scope which should be skipped
when asking questions in Set class.
Basically, the Set class will ask for each word which exists in sentence. If
you include common words, they will not be asked for.

This section is valid in Set classes. TODO reference.


Example usage:
\begin{verbatim}
\common{common.txt}
\end{verbatim}

The file must be included in the path or in current directory.
% 3}}} FIXcommon
% {{{3 FIXlang
\subsubsection{FIXlang option}
This will determine the language used in export. This is especially extractant
because it determines the common words which should be excluded from Set
questions.

Example usage:
\begin{verbatim}
\lang{en}
\end{verbatim}

Currently possible values are: \textit{en} and \textit{pl}.

% 3}}}
% {{{3 FIXjoined
\subsubsection{FIXjoined option}
This option includes a file with joined words which should not be split when
asking for words in Set class.
By default, all words with capital letters are joined if they happen to exist
side by side.

The file contents should be like this
\begin{verbatim}
file contents
stored eventually
\end{verbatim}

ie in each line should be words which should be connected if they happen to
exist exactly in this way.

Example usage:
For the following instructions:
\begin{verbatim}
\joined{joined.txt}
\begin{set}
The file contents is empty.
\end{set}
\end{verbatim}
extract will generate the questions:
\begin{verbatim}
q: The ... is empty.
a: file contents

q: The file contents is ....
a: empty.
\end{verbatim}

Notice that there were no double questions generated for \textit{file} and
\textit{contents} but they were merge into one.

% 3}}} FIXjoined
% {{{3 FIXcomment
\subsubsection{FIXcomment}
The comment in extract is done similarly to LaTeX: using the \% char.
Everything that is preceded by this char is commented.
Note that if you want to have this char, you must escape it, using backslash
character.
% 3}}}

% {{{3 FIXverbatim
\subsubsection{FIXverbatim}
This is a special mode of processing which stops treating all special
characters (ie backslash) in a special way

This is similar to LaTeX verbatim mode
Example:
\begin{verbatim}
begin{verbatim}
end{verbatim}
\end{verbatim}

THINK OF ANOTHER EXAMPLE ??!!!

see also subst command if you are interesting in changing only a couple of
chars.


% 3}}}


% {{{3 FIXsubst
\subsubsection{FIXsubst}
Subst command is used to temporarily substitute special char used by \probe\
language with another char. This is very useful when we want to learn a
text which contains many backslashes or interpunction signs.
The subst command make the substituted char loose it's original meaning.
Example:
% TODO remove comment!! Latex complains !
% How to write it ??
% \begin{verbatim}
% \subst{\%{(})}
%begin(set)
% Learning phrases %ignore(Friday,test) may be {very strenous} \said \adam.
%end(set)
% \end{verbatim}
This will make \probe\ forget the original special meaning of backspace, which
now can be used freely, but will treat all \% chars as backspace.

The above example will result in the following:
\begin{verbatim}
q: ... phrases may be {very strenous} \said \adam
a: Learning

q: Learning ... may be {very strenous} \said \adam
a: phrases

\end{verbatim}

% Remove comment! LatEx complains !!!
% The syntax works like this -> each char is substituted by the next char, so \{
% is substituted with ( and } with ).
% To remove subst you can use FIXunsubst command or next subst which forgets all
% subst made by previous subst.



This is my original -> it is not from latex as I know it ?

% 3}}}

% {{{3 FIXescape
\subsubsection{FIXescape}
Special escape sequence :
how to get chars which are forbidden : ??
can use the FIXverbatim command or the FIXsubst command but an easy way is to
use the escape backslash character e.g. backslash backslash

% 3}}}


% {{{3 FIXhint
\subsubsection{FIXhint}
OR comment

Hint special char \# gives possibility to include hints (In Mentor they may be
visible on demand only in supermemo right away)

This is more like  a comment over current item which is also displayed in the
answer or question to include more information.



The syntax is as follows (to possibilities)
\begin{verbatim}
\set
They asked me for \hint{Did they?}everything. I answered \hint[ok]{this will be
ok with merged!}
\end{verbatim}
Will result in:

\begin{verbatim}
q: They asked me for ...
a: everything
a: hint: Did they?
\end{verbatim}


In the first form - with hint keyword, the hint may work for the whole set fragment and in the
second with hash , it will work only for  the word that is right beside it or
the group. ??


\begin{verbatim}
\set
They asked me for #[Did they?]everything. I answered #[ok]{this will be
ok with merged!}
They asked me for #(Did they?)everything. I answered #(ok){this will be
ok with merged!}
\end{verbatim}


Or maybe alternate syntax with \# char

\begin{verbatim}
\set
\hint[Did they? ok]
They asked me for everything. I answered this will be
ok with merged!
\end{verbatim}
% 3}}}




% {{{3 FIXmode
\subsubsection{FIXmode}
The mode command determines how text should be processed. Possible values are
\textit{approx}, \textit{normal} and \textit{strict}. In \textit{approx} mode,
the language is as forgiving as possible - all possible options and formats are
deduced from the file and no errors are raised.
In \textit{normal} mode, only serious errors (like missing file) cause
\probe\ stoppage and all other errors are just reported as warnings.
In \textit{strict} mode, every little warning generates an error which stops
further processing.

The \textit{approx} mode is useful when we want to get around a file and have
some results quickly.
The \textit{strict} mode is useful when we want to be sure than any
errors go unnoticed. This is usually useful in the last iterations, when we
fixed all possible problems with given file.


Example usage:
\begin{verbatim}
\mode{strict}
\end{verbatim}

It is possible to have different modes in file. All text processed after mode
command, will be treated as it said.
These values may be also set from the command-line using option -mode
See:  TODO ref
% 3}}} FIXcommon
% 2}}} General constructs
% {{{2 Classes
\subsection{Classes}
Class is a set of rules how the source text should look like and how it should
be processed.  extract is designed to be able to parse all sorts of texts. To
allow for big diversity and yet power the concept of classes was born.
Class is a sort of subdialect with different rules and constructs to allow
parsing different kinds of texts.

It is also a way for easily extending the extract language. If you want to extend
you can just write a plugin class. For more information see chapter Extending
extract.

WARNING!
The general constructs may be used only outside any class - when occurring in a
class they will raise an error or result in the construct not being parsed
correctly.

%Hmm, OTOH some options and constructs like emph and ?? what other may be used ?
%How to distinguish that ??

% {{{3 Tabbed class
\subsubsection{Tabbed class}

In \textit{tabbed class}, each line is treated as an item. The question is everything
before tab, and answer everything after tab.
Only the first tab occurrence is taken into account, all others are ignored.
If not tab exists in a line, then the whole line is treated as an question and
answer stays empty. If the mode is strict, this will raise an error.

Empty lines are ignored completely.
If you have items which are longer than one line, you can use the backslash
character at the end of line to show the line will be merged.

Example:
\begin{verbatim}
\begin{tabbed}
What's the capital of Angola?TABAngola
America was discovered byTABAmerigo/ Vespucci
\end{tabbed}
\end{verbatim}

will result in:
\begin{verbatim}
q: What's the capital of Angola
a: Angola

q: America was discovered by
q: ... Vespucci
a: Amerigo Vespucci

q: America was discovered by
q: Amerigo ...
a: Amerigo Vespucci
\end{verbatim}


The whole right part of the line (after tab) is taken as an answer.
If you want to have the answer splitted into many parts, and thus more items
generated, then you must use the / char.

Options which may be used here:
\textit{swap} options which determines whether to generate




% 3}}} Tabbed class
% {{{3 QA class
\subsubsection{QA class}
This is very similar to \textit{Tabbed class} with only difference being that
each items consist of 2 lines of separate paragaphs. They are seperate by the
\emph{enter} char.

This may be useful when the lines are too long to displayed side by side, as it
is in \emph{Tabbed class}.
All other options of \emph{Tabbed class} apply here as well.

Example:
\begin{verbatim}
\begin{qa}
America was discovered by
Amerigo/ Vespucci

What's the capital of Angola
Angola
\end{qa}
\end{verbatim}

The above code will result in the following items:
\begin{verbatim}
q: America was discovered by
q: Amerigo ...
a: Amerigo Vespucci

q: America was discovered by
q: ... Vespucci
a: Amerigo Vespucci

q: What's the capital of Angola
a: Angola
\end{verbatim}


Note that the generated items are virtually the same as the items generated
from \emph{Tabbed class}.

Comments:
This is a counterpart to the old Mentor simple class

used this class to be

% 3}}}A QA class
% {{{3 Cloze class
\subsubsection{Cloze class}
\emph{Cloze class} is a class which selects specific fragments of text and
presents them as questions.
It is useful when there are only a couple of fragments which may be
interesting.
The most similar  /counter class for this is the Set class which is the exact
opposite - the \emph{Set} class extracts each token and treats it as a question to
ask, whereas \emph{Cloze} close extracts only token explicitly marked. In Set class
you must explicitly mark what you \emph{don't want} to export.


Example:

Example usage:
\begin{verbatim}
\begin{cloze}
 The source #distribution for the standard Python documentation contains a large
 number of directories. While third-party #{documents} do not need to be placed
 into this structure or #need to be placed within a similar structure, it can be
 helpful to know where to #{look for examples} and tools when developing new
 documents using the Python #{documentation^ tools}. This section describes this
 #directory #structure.
\end{cloze}
\end{verbatim}

This will result in file:
TODO

The items are seperated by . ????? what about sentence - maybe it should be an
option instead of a class.


% 3}}}A Cloze class
% {{{3 Comma-seperated class
\subsubsection{Comma-seperated class}
This class is similar to tabbed class but uses commas instead of TAB
characters.

e.g. this text will be transformed:


% 3}}}A Comma-seperated class
% {{{3 Set class
\subsubsection{Set class}
The \emph{Set class} treats the source text as something you want to learn
thouroughly. It takes every word from source text and creates question/item for
it.
It ignores the standard and common words, depending on the language setting. It
is also possible to extend \probe\ with your own common words and languages.

The opposite of \emph{Set class} is the \emph{Cloze class} which extracts only
those words which you mark explicitly.


Example usage:
\begin{verbatim}
\begin{set}
 The source !distribution for the standard Python !{documentation contains a
 large} number of directories. While third-party documents do not need to be
 placed into this !structure or need to be placed within a similar structure, it
 can be helpful to know where to look for examples and tools when developing
 new documents using the Python documentation tools. This section describes
 this directory structure.
\end{set}
\end{verbatim}

This will result in file:

\begin{verbatim}
q: The source distribution for the standard Python documentation contains a
large number of directories.

\end{verbatim}

TODO

WARNING!
Maybe extend this to 3rd basic class, beside Set and Class which will select
sentences broken on / char??





% 3}}}A Set class
% {{{3 Code class
\subsubsection{Code class}

This is a general class which may be used to generate items out of programming
constructs. It may be useful if one wants to memorize some function signatures.

It may seem unnecessary in XX century when you have intellisense everywhere,
but sometime it is better to keep code in ones head, and besides intellisense
is not available eveywhere.

By default it will try to use heuristics to recognize the language used -
sometimes however the heuristics may not work and you may give an option to the
code class.  Currently the following languages are supported:

\begin{verbatim}
options: [lang=c/pascal/java/javascript/python] etc.  signatures the code
itself as well or not ?
\end{verbatim}


The extractant fact about this class is that the exact formatting of the source
code must be preserved.

Example:
\begin{verbatim}
\begin{code}[python]
for i in 1..2:
    print i
\end{code}
\end{verbatim}

This will result in the following questions:
\begin{verbatim}
q: ... i in 1..2:
q:     print i
a: for

q: for ... in 1..2:
q:     print i
a: i

q: for ... in 1..2:
q:     print i
a: i


q: for i ... 1..2:
q:     print i
a: in
[...]
\end{verbatim}

This is similar to Set/Cloze class but uses different files/words for
excluding/including from test.

Note:
Also signature/definitions tests!!!!

Some special cases when I'm interested in code function signatures, code
classes signatures, or the source code itself (all the calls and functions).

The code class also supports a set of options:
lang=pascal|java|c|cpp|ruby|python -> what language it should use?
numbers=yes|no -> should it ask for numbers?
strings=yes|no -> should it ask for strings?
punctation=yes|no -> should it ask for punctaction?




% {{{3 Doxygen class
\subsubsection{Doxygen class}
This is also a special unique mode which will parse doxygen/javadoc
comments and prepare questions basing on them .
Options include possibility to select what should be processed:
which comments etc.
% 3}}}

% {{{3 Database class
\subsubsection{Database class}
This is a special, unique mode which will connect with database , retrieve it's
tables and schemas and will prepare nice questions.
Maybe generate graphically in Visio or in it's own library (Qt??)
Option include possibility to :
select what should be processed
% 3}}}

% 3}}}A Code class
% {{{3 Signature class
\subsubsection{Signature class}
This is actually a special case of Code class, created especially for
code signatures, ie function, procedure and class headers.

It currently detects:
- function headers
- procedure headers
- variables
- properties

It will take the following signatures and convert them to question and answers:

\begin{verbatim}
\begin{signature}[lang=pascal,types=yes,return=no]
  function DateTimeToString : Boolean;
  function DateTimeToString (var Result: string; const Format: string; DateTime: TDateTime) : Boolean;
  procedure DateTimeToString(var Result: string; const Format: string; DateTime: TDateTime);
  procedure DateTimeToString;
\end{signature}
\end{verbatim}

This will result in the following:
As you can see, it is asked for enumerating all params  and then for details ->
for giving each argument a detailed info variable name, variable type etc.

\begin{verbatim}
Q: DateTimeToString(...)
A: -

Q: DateTimeToString
Q: DateTimeToString?
A: function DateTimeToString : Boolean;

Q: DateTimeToString(...; Format; DateTime)
A: var Result

Q: DateTimeToString(var Result; ...; DateTime)
A: Format

Q: DateTimeToString(var Result; Format; ...)
A: DateTime

Q: DateTimeToString(var Result; Format; DateTime)
Q: var Result?
A: var Result: string

Q: DateTimeToString(var Result; Format; DateTime)
Q: Format?
A: const Format: string

Q: DateTimeToString(var Result; Format; DateTime)
Q: DateTime?
A: DateTime: TDateTime

Q: DateTimeToString(var Result; Format; DateTime)
Q: DateTimeToString?
A: function DateTimeToString (...) : Boolean;

Q: DateTimeToString(...; Format; DateTime)
A: var Result

Q: DateTimeToString(var Result; ...; DateTime)
A: Format

Q: DateTimeToString(var Result; Format; ...)
A: DateTime

Q: DateTimeToString(var Result; Format; DateTime)
Q: var Result?
A: var Result: string

Q: DateTimeToString(var Result; Format; DateTime)
Q: Format?
A: const Format: string

Q: DateTimeToString(var Result; Format; DateTime)
Q: DateTime?
A: DateTime: TDateTime

Q: DateTimeToString(var Result; Format; DateTime)
Q: DateTimeToString?
A: procedure DateTimeToString(...);

Q: DateTimeToString(...)
A: -

Q: DateTimeToString
Q: DateTimeToString?
A: procedure DateTimeToString;
\end{verbatim}


It also supports a set of options to control what language should be used.
Currently supported languages:
lang=pascal|java|c|cpp|ruby|python|plsql -> what language it should use?
types=yes|no -> should it ask for types?
returns=yes|no -> should it ask for return type?
procfun=yes|no -> should it ask for proc or function
constant=yes|no -> should it ask for constants?
enumparams=yes|no -> should it enum params one by one


Comments:
maybe also something like this for class hierarchy ??
and other control structures ??


Here is another example, this time for C language:
\begin{verbatim}
\signature{c}
main (int argc, char *argv [])
void * main(int argc, char argv)
\endsignature
\end{verbatim}
This will result in the following:

\begin{verbatim}
Q: main(..., argv)
A: argc

Q: main(argc, ...)
A: argv

Q: main(argc, argv)
Q: argc?
A: int argc

Q: main(argc, argv)
Q: argv?
A: char *argv []

Q: main(argc, argv)
Q: main?
A: main (...)

\end{verbatim}
What about the last question? I think it is broken, or??


Also have the possibility to include comments -> which will be asked for
As well as doxygen/javadoc comments -> special mode for parsing them


Property export in signature class will allow for something like:
\begin{verbatim}
.pascal

property ala : string read getala write setala;
property ala : string read getala;
property ala : string write getala;
\end{verbatim}

% 3}}}
% {{{3 Lang class
\subsubsection{Lang class}
This class is especially designed to learn foreign languages. It will be
coupled with my Vokabel program perhaps.

It has some special features especially destined for words:
english - polish - example - peg
seperated by TAB char or by ;

It will be like csv file more


mother TAB matka  TAB matka jest jedna  TAB matttka

or maybe delimited by CR ??






% 3}}}
% {{{3 Definition class
\subsubsection{Definition class}
This class is used to remember exact definition of a word.
It is kind of a \emph{Set class} but with first part (the question) not asked.
The swap option may be included here too.

In definition mode , the IGNORED/COMMON words are ignored
\begin{verbatim}
\begin{definition}
blue color?
color of the sky
\end{verbatim}

OR

\begin{verbatim}
\definition
blue color? color of the sky
\end{verbatim}

Resulting in:
\begin{verbatim}
Q: blue color??
Q: ...
A: color...

Q: blue color??
Q: color of the ...
A: sky
\end{verbatim}


As I think of it , it may be a variant of the tabbed class.
The difference is that the delimeter there was TABs and here it's question mark?

The definition mode has option what is the delimeter - maybe it should be one
class Delimited or Twopart ??

Simple/QA class is also a part of that : it has enter as a delimiter
% [delim=\t]
% [delim=?]

And the option how to treat the second part
as a set: %  ~ to ignore    , common ignored , ^ to join  { } to group  what
% about # ??
as a cloze % ? to learn
as a whole part % / to break



% 3}}}
% {{{3 Sentence class
\subsubsection{sentence class}

The \emph{sentence} class is a sort of subclass of the \emph{Set} and
\emph{Cloze} classes with the difference of how the input text is treated.

In \emph{sentence} class each sentence, ie a sequence of chars terminated by .
(unless it's an abbreviation but this is detected looking at the next letter).
The items are selected using the Cloze of Set method, depending on whether
special chars like // or \^ exist.


The \emph{Sentence class} is most suitable This class is
This is the most general class which is suitable for pure articles.  It will
just extract each sentence and try to extract extractant information from it.

It will go paragraph by paragraph.

Each item is a sentence, the items are processed in set mode ???


Example:
\begin{verbatim}
\begin{sentence}
An alternate syntax for a group using brackets, [...], is used by macros and
environment constructors which take optional parameters; brackets do not
normally hold syntactic significance. A degenerate group, containing only one
atomic^bit of content, does not need to have an explicit group, unless it is
required to avoid ambiguity. Since Python tends toward the explicit, groups are
also made explicit in the documentation markup.
\end{sentence}
\end{verbatim}

This will result in the following:
question for the first sentence:
\begin{verbatim}
Q: An ... syntax for a group using brackets, [...], is used by macros and
environment constructors which take optional parameters; brackets do not
normally hold syntactic significance.
A: alternate

Q: An alternate ... for a group using brackets, [...], is used by macros and
environment constructors which take optional parameters; brackets do not
normally hold syntactic significance.
A: syntax


Q: An alternate syntax for a ... using brackets, [...], is used by macros and
environment constructors which take optional parameters; brackets do not
normally hold syntactic significance.
A: group
[...]
\end{verbatim}


and question for the second sentence:
\begin{verbatim}
Q: A ... group, containing only one atomic bit of content, does not need to
have an explicit group, unless it is required to avoid ambiguity.
A: degenerate

Q: A degenerate ..., containing only one atomic bit of content, does not need to
have an explicit group, unless it is required to avoid ambiguity.
A: group

Q: A degenerate group, ... only one atomic bit of content, does not need to
have an explicit group, unless it is required to avoid ambiguity.
A: containing

Q: A degenerate group, containing only one ... of content, does not need to
have an explicit group, unless it is required to avoid ambiguity.
A: atomic bit
[...]
\end{verbatim}

.. and so on.
Please notice the use of \^ char in the second sentence which resulted in
joining \emph{atomic bit} into one word.

% 3}}} Sentence class
% {{{3 Paragraph class
\subsubsection{Paragraph class}
This is similar to Sentence class but is different in that sense that each
paragraph makes an item.
Thusly,  seperator is not a dot but (at least) double enter.


This may be useful if we want to have the whole paragraph contained in an
answer.


Example:
TODO example


% 3}}}
% {{{3 Graphical class
\subsubsection{graphical class}
\probe\ will work with graphical items as well as text items will export to su
SuperMemo ITEms Tools .  Graphical repetitions work by selecting a fragment of
a picture and trying to remember what the cloze was about.  Currently export of
graphical class to SuperMemo is limited but the Mentor program works with it
quite well.

The syntax is as follows:

\begin{verbatim}

\begin{graphics}graphics{hello.bmp}
\pic[10,20]
\pic[10,30,50,50]
\end

\end{verbatim}
% 3}}} Graphical class
% 2}}} Classes
% {{{2 Options
\subsection{Class options}

Each class has a set of options which may be used to tweak it's mechanizm.
Generally options are used to modify the class in a slight way - if you want
some bigger changes then you should use another class.


% {{{3 swap option
\subsubsection{swap option}

This option determines whether the items should be swapped or not. By default,
\probe\ will generate one question and answer out of items in sentence or tab
class.  If you want the opposite question and answer to be generated, you
should set this option.

\begin{verbatim}

options:
 [swap]
 [noswap]
   should the item be swapped ?
   when questioning?
   e.g.
   what is your subject?
   maths

   when swapped this will translate to ->
   q: what is your subject?
   a: math
   and swapped question:
   q: math?
   a: what is your subject

   [TODO] find a better example


\end{verbatim}


% 3}}}

% {{{3 ignore option
\subsubsection{ignore option}
This will enable to ignore common words mode by specifiying them in
the source file directly. This is useful which in \emph{Set class} mode.

Example:
\begin{verbatim}
\ignore{and,if,store,quit}[file=common.txt]
\begin{set}
Quit store if I ask you!
\end{set}
\end{verbatim}

this will result in:
\begin{verbatim}
q: Quit store if I ... you!
a: ask
\end{verbatim}

All the included common words , plus the ones included in file common.txt will
be now ignored.

NOTE : for common words, use corpus to include the most commonly used words in
different languages.


% 3}}}

% {{{3 unignore option
\subsubsection{unignore option}
This will enable unignore common words by specifying them directly in the
source code. This is useful which in \emph{Set class} mode.

This is analogous to FIXignore option but works exactly opposite.

SEE also FIXcommon option --> maybe should change it to ignore options

% 3}}} unignore



% 2}}} Options
% {{{2 Special constructs
\subsection{Special constructs}

This subsection describes special constructs which may be used all over the
file, in almost all classes.
Warning! Appearance of some special constructs determines the class /??

% {{{3  The \^ char
\subsubsection{The \^ char}
The joining char is used to join words which should be used together.
This is especially useful for Set class which asks for each word in given text.


When words will be joined with \^ , .eg. \textit{America was discovered by
Christoph\^Columbus} then
In Set class, this would result in asking for each word seperately. By joining
Christoph Columbus in one it will appear only once in answer.

Note: some words are joined automatically. E.g. words beginning with capitals
near themselves are automatically joined.

The is also FIXjoined command and special char \ FIXbackslash which will split
them

% 3}}}
% {{{3 The ! char
\subsubsection{The ! char}
The ! char describes the word following it should be excluded from the export.
It is useful also in the Set class, which selects all words from given text.


% 3}}}
% {{{3 The / char
\subsubsection{The / char}
This is the 'przeciwienstwo' of the \^ char which would join - it would split
the names. It is useful also in the Set class questioning - when you want to
split despite the default rules being joining the words with capitals.

% 3}}}
% {{{3 The \\ char
\subsubsection{The \\ char}
This char is used at the end of line to denote multi-line statement.
If in \textit{strict} mode, then no white chars may appear after it.

This may be useful when e.g. in Tab mode we want to have item which is quite
long but we want it to appear on the screen. So we put it in many lines and by
using the \\ char we ensure it will be treated as one char.
% 3}}}
% 2}}} Special constructs
% 1}}} extract markup language
% {{{1 Examples
\section{Examples}
This section presents examples of \probe\ usage in order to better present
it's usage language.



% 1}}} Examples
% {{{1 Extending extract
\section{Extending extract}
This chapter explains how to extend extract with your own classes.
extract engages the concept of classes which are set of rules how the text should
be parsed.


extract is written in Python language which is a simple yet powerful language for
prototyping and writing ever larger applications. Extending extract requires
learning a little of Python - you cannot currently use any other language.

The file must be named after the class e.g. simple.py which will have Simple
class , descending from Class object. It maybe some more specialized class if
you want to use some functions already predefined.

The Simple class must adhere to the interface . The interface is specified
below.

All classes are written according to interface class. They just provide
functions which are used by general class.



\subsection{extract classes interface}

The class interface is quite simple really.
It consists of the following functions:

\begin{verbatim}
get_next_item(options, tokenizer, item) : int
\end{verbatim}

It should return 1 on success , 0 on failure (end) or raise an exception if an
error occurred (depending on mode and options)


options is a set of options as parsed by the general parser.
tokenizer will have 2 functions:
\begin{verbatim}
get_next_token : bool
push_back
set_options
\end{verbatim}

"set\_options may be used to specify what chars should be treated as tokens
get\_next\_token just returns token , will it be a word or a special construct

item must be created by this function: using create\_item(q, a) where q is
question text and a answer text. There may be some formatting (like color,
emphasis etc.) used.


Will the token be a line or what ?  a word ??
what about fixed words??????


The best pattern is to use generators for this



% 1}}}
% {{{1 Other applications

\section{Other applications}

Other apps which I based myself on are:
\begin{enumerate}

\item[SuperMemo] this is THE program for making repetitions. It is
  traditionally geared more towards learning language than for any other
  purpose.

\item[Mnemosyne]this is an opensource version of SuperMemo , written in
Python and Qt. It is also geared towards word learning and therefore it
is not very suitable for my needs. It certainly was an inspiration
though.

\item[Mentor] this is another program which may be used to quickly test knowledge prepared by \probe\.
It's developed by \probe\ author so integration with it is quite simple.

\end{enumerate}

% 1}}} Other applications
% {{{1 Feedback
\section{Feedback}
This is initial release of this script - it is far from perfect and may
contain several bugs.
If you notice any bugs or have any comments about this program, please
send info to: santhalus AT gmail DOT com


% 1}}} Feedback
%
\end{document}
% this does not work ????!!!
% maybe becaue of the latex suite ?
% do: set formatoptions+=t to have it formatted
% set tw=79
% set fdm=marker
% vi:tw=79 fo=qat fdm=marker:
